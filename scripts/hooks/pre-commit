#!/bin/sh

# Get the current user and timestamp
current_user=$(git config user.name)
current_timestamp=$(date +"%Y-%m-%d %H:%M:%S")

# Function to add or update metadata in a file
update_metadata() {
    file=$1
    # Get the current commit message from the staged changes
    commit_message=$(git log -1 --cached --pretty=%B 2>/dev/null || git log -1 --pretty=%B 2>/dev/null)
    if [ -z "$commit_message" ]; then
        # If no commit message is found, use the message from the current commit being made
        commit_message=$(cat "$GIT_DIR/COMMIT_EDITMSG" 2>/dev/null)
    fi

    if grep -q "creator name:" "$file"; then
        # Add new row to the metadata table
        # Find the last line of the metadata table
        table_end=$(grep -n "^-\{80\}$" "$file" | head -n 1 | cut -d: -f1)
        if [ -n "$table_end" ]; then
            # Create temporary file with new metadata
            awk -v user="$current_user" \
                -v version="$(get_next_version "$file")" \
                -v timestamp="$current_timestamp" \
                -v message="$commit_message" \
                -v end="$table_end" \
                '{
                    print;
                    if (NR == end) {
                        printf "%-20s %-15s %-23s %s\n", user, version, timestamp, message;
                    }
                }' "$file" > "$file.tmp"
            mv "$file.tmp" "$file"
        fi
    else
        # Create temporary file with initial metadata
        {
            echo "#creator name: $current_user"
            echo "#creation time: $current_timestamp"
            echo "#Modified by            Version          Modified timestamp         Commit message"
            echo "#--------------------------------------------------------------------------------"
            printf "#%-20s %-15s %-23s %s\n" "$current_user" "1.0" "$current_timestamp" "$commit_message"
            echo ""
            cat "$file"
        } > "$file.tmp"
        mv "$file.tmp" "$file"
    fi
    git add "$file"  # Stage the changes
}

# Function to calculate the next version number
get_next_version() {
    file=$1
    # Find the last version number in the metadata table
    last_version=$(awk '/^[A-Za-z]+ +[0-9]+\.[0-9]+ +[0-9]{4}-[0-9]{2}-[0-9]{2}/ {ver=$2} END {print ver}' "$file")
    
    # Check if last_version is empty or invalid, default to "1.0"
    if [ -z "$last_version" ] || ! [[ "$last_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        echo "1.0"
        return
    fi
    
    major_version=$(echo "$last_version" | cut -d. -f1)
    minor_version=$(echo "$last_version" | cut -d. -f2)
    
    # Increment minor version, if it reaches 9, increment major version
    if [ "$minor_version" -eq "9" ]; then
        new_major_version=$((major_version + 1))
        new_minor_version="0"
    else
        new_major_version="$major_version"
        new_minor_version=$((minor_version + 1))
    fi
    
    echo "$new_major_version.$new_minor_version"
}

# Find all SQLX, SQL and PY files that are staged for commit
for file in $(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(sqlx|sql|py)$'); do
    update_metadata "$file"
done

exit 0